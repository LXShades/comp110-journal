\documentclass{journal}

\title{On Goto Killing You in Your Sleep}
\author{Louis Foy}
\date{\today}

\begin{filecontents*}{references.bib}
@article{goto,
    title = "Go to statement considered harmful",
    author = "Edsger W. Dijkstra",
    journal = "Communications of the ACM",
    volume = "11",
    issue = "3",
    month = "Mar",
    year = "1968",
    pages = "147-148",
    address = "New York, NY",
    url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=362947&CFID=827503237&CFTOKEN=60937548"
}

@article{algolwirth,
    title = "A contribution to the development of ALGOL",
    author = "Niklaus Wirth and C. A. R. Hoare",
    journal = "Communications of the ACM",
    volume = "9",
    issue = "6",
    year = "1966",
    month = "Jun",
    pages = "413-432",
    address = "New York, NY",
    url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=365702"
}

@article{algolguide,
    title = "An introduction to ALGOL 60"
}

@article{gotoodeep,
    title = "Go to considered harmful considered harmful"
	url = "http://web.archive.org/web/20090320002214/http://www.ecn.purdue.edu/ParaMount/papers/rubin87goto.pdf"
}

@article{loopbreaking,
    title = "Multiple exits from a loop without the GOTO",
    url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=362300&CFID=827503237&CFTOKEN=60937548"
}

@article{gotostudy,
    title = "An empirical study of goto in C code from GitHub repositories",
	author = "Meiyappan Nagappan et al.",
    url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=2786834&CFID=827503237&CFTOKEN=60937548"
}

@article{againstgoto, 
    title = "A case against the GOTO",
	author = "W. A. Wulf",
	url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=987372"
}

@article{harmfulstructure,
    url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=987280&CFID=827503237&CFTOKEN=60937548"
}

@article{pascalrecollections,
    url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=1057812&CFID=827503237&CFTOKEN=60937548"
}

@article{pathfinding,
    title = "A note on two problems in connexion with graphs",
    author = "Edsger W. Dijkstra",
    month = "Dec",
    year = "1959",
    pages = "269-271",
    volume = "1",
    booktitle = "Numerische Mathematik",
    url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=2722945"
}

@article{truths,
    title = "How do we tell truths that might hurt?",
	author = "Edser W. Dijkstra",
	month = "May",
	year = "1982",
	booktitle = "ACM SIGPLAN Notices",
	volume = "17",
	issue = "5",
	pages = "13-15",
	address = "New York, NY"
}

@book{structured,
    title = "Structured programmin",
	author = "O. J. Dahl et al.",
	year = "1972",
	address = "Academic Press Ltd., London, UK"
	url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=1243380&CFID=828454876&CFTOKEN=46578168"
}

@book{cprogramming,
    title = "The C Programming Language",
	author = "Brian W. Kernighan and Dennis M. Ritchie",
	url = "http://www.dipmat.univpm.it/~demeio/public/the_c_programming_language_2.pdf"
}

@article{github,
    title = "The promises and perils of mining on GitHub",
	author = "Eirini Kalliamvakou",
	booktitle = "Proceedings of the 11th Working Conference on Mining Software Repositories",
	pages = "92-101",
	month = "May",
	year = "2014",
	url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=2597074&CFID=828454876&CFTOKEN=46578168"
}
	
@article{structuredgoto,
    title = "Structured programming with Goto Statements",
	author = "Donald E. Knuth",
	url = "https://dl-acm-org.ezproxy.falmouth.ac.uk/citation.cfm?id=356640&CFID=828454876&CFTOKEN=46578168"
}
	
\end{filecontents*}

\usepackage{graphicx}

\begin{document}
\maketitle

% Basic competency: 40% 1 peer review, viva discussion, citations appropriate, academically integral
% Breadth of reading: 10% -- read lots of articles, 16 of them!
% Depth of insight: 15% Significant insight demonstrated. Discussion is anlytical and evaluative in nature
% Specificability, verifiablility and accuracy of claims: 10%, all claims have a clear source of evidence. Almost no errors/misinterpretations.
% Synthesis: 15%, Info from multiple sources synthesised into a strongly cohesive whole. Connections are analytical and evaluative.
% Spelling & grammar: 5%
% Structure: 5%
% \textbf \textit \underline

\section{\textunderscore \textunderscore Introduction:;}
In March 1968, a notorious paper was published. Titled 'Go to statement considered harmful' \cite{goto}, it was written by Edsger W. Dijkstra, an influential pioneer of computer science during its early days, if `influential' were a measurement of the vast swathes of `considered harmful' papers one could instantly inspire across acedemia (CITE). His paper can be summarised as a criticism that using goto statements causes the flow of the program's execution to diverge greatly from the flow of text, by allowing the process to jump to various areas in code in an unstructured manner, with no obvious indicators from where it came. Due to the compromise in human readability he proposed that the use of goto statements be avoided outside machine level code.

In their cricitism of what was once common practice in the era[CITE], Dijkstra's statements were quite bold. While his motivation was apparently a negative correlation between programming quality and the number of goto statements in the code \cite{goto}, the observent would recognise Dijkstra as the creator of the popular pathfinding algorithm now known by his name \cite{pathfinding}, and could very reasonably argue that his hatred for the goto statement manifested because the ability to simply `go to' some code is far too easy for the programmer. As Dijkstra's collision-free descent into madness that pulled many programmers and academics along with him in the cold grasps of the ``considered harmful'' phenomenon took place, in the ever deeping existential crisis illustrating how virtually everything in programming is flawed in some way as our souls are sold to the megacorporations of tomorrow \cite{truths}, he reminisces.

For the next part of the essay \textbf{goto ``To Pascal''}

\section{Conclusion}
If you arived here before reading the rest of the essay please restart the program.

Today it is truly a wonder whether the goto statement has a right to exist, similar to the enigma of whether programmers have a right to exist with it. This appears to be why the goto statement is still around today; while 90\% of uses could be resolved with forward-only specialised jump statements, nobody can truly predict how the volatile community of programmers would react. Thus it seems that goto is here to stay, at least until another new programming language comes along. With the dawn of quantum computing, there is still hope yet; until then, we live with popular programming languages that stand at about 30 to 50 years old.

\section{``Goto'' in Practice:;}
To see whether a backwards goto statement should be useful, it is worth discovering where goto is typically used in the first place. An extensive study \cite{gotostudy} of one of the world's largest open code repositories \cite{github}, GitHub, found that most goto statements in modern C code are used for error handling. This is usually characterised by a function, sometimes one which loads various error-dependent resources, followed by a function end returning success, then followed by an `error:' label of such, beneath which any successfully-loaded resources are freed before returning. This is popular, but does not necessitate a backwards-capable goto statement as the error condition is usually placed at the end of the function \cite{gotostudy}. [MAKE A CODE FIGURE]

The study itself ultimately concluded that 90\% of goto uses were forward only, and believed to be used for reasonable purposes. It can thus be safely assumed that the programmer may in fact have a say of the devil's powers after all, and that goto can be used for good, and it is perhaps us who are evil.



\section{OOP considered harmful?}

\section{To Pascal:;}
Dijkstra's disdain was not unique. His paper itself found inspiration from the words of N. Wirth, who with C. A. R. Hoare \cite{algolwirth} advised the demotion of labels and go to statements whilst proposing changes to the ALGOL language in 1965, with a similar rationale that the structure of a program would be clearer with alternative 'case' statements and loops. In their proposal, 'goto' would be stripped of all complexities, leaving no more than a usable statement should the ability to jump anywhere in code be needed.

For a trivial side remark about the proposed case statements, set \textbf{x} to here, then \textbf{goto} "Switch statements".

It is as such arguable that it was Wirth who took the more active role in demoting goto in favour of structured programming (considered harmful \cite{harmfulstructure}). When his and his team's proposals for ALGOL were rejected in favour of a more complex overhaul (to become ALGOL 68) \cite{pascalrecollections}, Wirth went on to produce ALGOL W, whilst the Working Group created ALGOL 68. Soon after, ALGOL 68 failed, creating a new hole in the market through which Wirth's next language, Pascal \cite{pascal} would begin to thread in 1970 \cite{pascalrecollections}.

Wirth's goal with Pascal was to advance programming, despite the presence of far more popular, yet stagnated languages, and create a language with improved structure and easier learning curve \cite{pascal}. With regards to goto, Pascal aimed to push structured programming, explained in great detail in a book partly authored by Dijkstra himself \cite{structured} reiterating the need for code to flow roughly proportionally to the internal process.

Yet contrary to all the developments above, for some reason, goto statements still existed, even implemented into Pascal itself \cite{pascal}. \textbf{goto ``Prevalence of the goto feature''}.

\section{Prevalence of the goto feature:;}
Much like a cigarette package or forbidden fruit, this functionality somehow still lies available to us, with 'DO NOT USE' written on it.  In fact, one of the most popular programming languages of today, C, has a functional goto statement \cite{cprogramming}, described by D. Ritchie as `infinitely abusable and unnecessary' \cite{cprogramming} while he gleefully implemented it into the compiler. It calls to question, if goto were truly harmful, why is it still included in modern programming languages? Even Microsoft's modern interpretation of C++, C\#, features a version of goto that is in fact expanded to also support switch labels[CITE]. Why plant evil in the garden and call it a weed?

There are valid uses for goto, some of which were illustrated in F. Rubin's article \cite{gotoodeep} disputing Dijkstra's original statement. A popular use, shown in the article itself, is when breaking out of deeply embedded scopes under a particular condition without needing to check that condition to leave each scope [FIG]. This is in fact also described in the C programming book itself \cite{cprogramming}. Hypothetically speaking, is there an alternative way to do this? When the issue is that we need to jump to a different area of code, namely a different scope, a jumping statement seems like a reasonable solution. And in order to break out of a scope into a different particular one, would it not be best to refer to it by a name--a label--so that the level of scope can change in the future? Is that not a goto statement?

An article by W. Wulf \cite{againstgoto} addresses one particular solution to the above problem, featured in the Bliss programming language: to include a 'leave' statement to escape from a loop and jump to a label. This is safer than a goto statement with its risk of making code unreadable (which is goto's fault [CITE MANY], and definitely not the programmer's), since it can only jump forward. This is a very logical solution, but calls to question whether it is really worthy to replace goto, as merely a restricted form of the same thing? A deeper question would be whether there is any use left for a goto statement that goes backwards in a world wherein many believe any such goto in any text is explicitly evil[CITE]?

To find out uses for backwards gotos \textbf{goto ``Goto in practice;'}


It may be that `goto' is included just to ensure the feature is available for special cases. However, given the extreme unpopularity of the goto statement[CITE], programmers are likely to avoid using it, sometimes at the expense of line count and computation time.

\section{Switch statements:;}
Interestingly, the 'case' statement proposal was intended to replace the 'switch' statement of ALGOL 60, which at the time was effectively a declaration of an array of labels to be used with a dynamic 'goto' statement \cite{algolguide}. What makes this interesting is the contrast to the modern switch statement of the C family today, which essentially defines 'switch' as what was once Pascal's 'case', and 'case' as what was once the labels, but restricted within the scope of the switch statement. As C was inspired by the ALGOL family, including Pascal, it is likely that the creator of C considered this small reinterpretation as a more correct terminology.

[put a figure here illustrating the different uses of the switch statement?]

Goto \textit{x}

\textbf{Please goto section }

\section{Benefits of goto:;}
Crap, wrong section. \textbf{Goto ``Pains of Goto''}

\section{Conclusion}
If you have reached this section before reading the rest of the paper please restart the program. You missed a goto statement.

\section{Stupid/funny stuff}
Granted, Dijkstra's pathfinding algorithm was in fact free. And it actually worked. But programmers work in mysterious ways. This author, for one, has paid their institution Â£9250 so that they can write heaps of essays for the institution. And frankly they make no sense at all.

And I for one would find it humourous that the A* algorithm was originally written entirely in goto statements.

Motive to subtly incorporate his pathfinding algorithm into every programming language on the market, where to write a program you had to place instructions in a complex maze with walls made of 0xCC, for the CPU to find and execute without colliding with the break instructions.

(From Pascal) If the divisor is a constant of c = 2\textsuperscript{n}, where *n* is *n*-ything, the compiler optimises this to a right bitshift.

\section{Journal -- personal thoughts on the paper itself}
The opening paragraph of this paper is very bold. It's littered everywhere with 'go to' statements; frankly I feel that this article is extremely inefficient and looks like spaghetti code. Furthermore, it makes bold claims that 'go to' should be abolished from all programming languages. \textbf{Explore:} Uses of go to in the modern age, particularly in C++. Introduction of structured programming languages. Etc

In paragraph 3, he makes a point to better visualise the dynamic process of the program, noting that code is a static set of instructions representing a dynamic set of processes that is hard for the human brain to process. He wants to create a simpler link between the program (in text) and the process (spread over time).

In paragraph 4 he begins to make things complicated by introducing 'textual indices', where you can point to an area in the code with rough equivalence to the point of the process being performed by a computer. In paragraph 5 if and else statements are illustrated as similarly simple. No doubt, this will all become much more complicated when goto statements come into play.

In paragraph 5, procedures come in. Interestingly these are kind of like areas for goto statements, too. And I can speak from personal experience that writing my code in a messy, linear fashion; despite the cost of maintainability, actually makes it much easier to debug because all the code is written, linearly, in one place. This is one thing I can't wrap my head around in OOP. When things become moduler I struggle to wade through it all. But that's another story.

By paragraph 6, he explains what is essentially the stack. So long as you keep a list of the textual indices, referring to the calling points from which you jumped into the next procedure, you can characterise your progress through the program.

Paragraph 7 introduces while loops. He remarks that we could already theoretically create loop with functions that call themselves (not mentioning the inevitable stack overflow, mind). He remarks that textual indices are no longer sufficient. We've gone too deep. It's over. But not quite. Introducing the dynamic index, counting the number of repetition. With more nested loops, more textual and dynamic indices come in. But the process is still alive, and it's okay.

Paragraph 8 he finally explains why he took us on that perilous journey. The indices are markers of progress. They're vital, but always invisible to the programmer. Except when the programmer's debugging, but we don't want to do that before the bugs appear.

The remainder of his argument is a well-written elucidation of common programming sense. Go to lets you jump around haphazardly with no indications of the program's progress other than the state of the program itself. 

\section{Journal -- thoughts on the context}
It's 1968. Computers aren't even home computers yet. TODO: Read more about the historical context.

\section{Journal -- thoughts on related papers}
\textit{The programming language pascal}: Written with structured programming in mind. Made as a simple starting language. Supported data structures (compare to ALGOL?). Compiler for Pascal was written in Pascal.

\section{OOP considered harmful?}
Explore OOP, such as C++, and how it shares the confusing properties of goto.

\bibliography{references}
\bibliographystyle{ieeetr}
\end{document}
